import { readFileSync, writeFileSync, existsSync, mkdirSync, promises as fs } from 'fs';
import { join } from 'path';
import { randomUUID } from 'crypto';

/**
 * Frontend Tests Agent
 * Reads frontend.ts and creates comprehensive tests based on actual code structure
 */
export class FrontendTestsAgent {
  
  async generateFrontendTests(): Promise<void> {
    console.log('  üß™ Frontend Tests Agent: Analyzing frontend code...');
    
    try {
      // Ensure outputs/tests directory exists
      this.ensureTestDirectory();
      
      // Read and analyze frontend.ts
      const frontendCode = this.readFrontendCode();
      const codeAnalysis = this.analyzeFrontendCode(frontendCode);
      
      console.log(`  üîç Found ${codeAnalysis.fields.length} form fields`);
      console.log(`  üîç Found ${codeAnalysis.validationFunctions.length} validation functions`);
      
      // Generate test file
      const testContent = this.generateTestFile(codeAnalysis);
      const testFile = 'outputs/tests/frontend.test.ts';
      writeFileSync(testFile, testContent);
      console.log(`  ‚úÖ Generated ${testFile}`);
      
      // Generate HTML test report
      const htmlReport = this.generateHtmlReport(codeAnalysis);
      const reportFile = 'outputs/tests/test-report.html';
      writeFileSync(reportFile, htmlReport);
      console.log(`  ‚úÖ Generated ${reportFile}`);
      
      // Check if we should request backend changes
      await this.checkForBackendRequests(codeAnalysis);
      
    } catch (error: any) {
      console.error('  ‚ùå Frontend Tests Agent error:', error.message);
    }
  }
  
  /**
   * Ensure test directory exists
   */
  private ensureTestDirectory(): void {
    if (!existsSync('outputs')) {
      mkdirSync('outputs');
    }
    if (!existsSync('outputs/tests')) {
      mkdirSync('outputs/tests');
      console.log('  üìÅ Created outputs/tests/ directory');
    }
  }
  
  /**
   * Read frontend.ts code
   */
  private readFrontendCode(): string {
    try {
      return readFileSync('src/frontend.ts', 'utf8');
    } catch (error) {
      throw new Error('Could not read src/frontend.ts');
    }
  }
  
  /**
   * Analyze frontend code to extract structure
   */
  private analyzeFrontendCode(code: string): CodeAnalysis {
    const analysis: CodeAnalysis = {
      fields: [],
      validationFunctions: [],
      interfaces: [],
      hasAuthenticateUser: false
    };
    
    // Extract LoginForm interface fields
    const loginFormMatch = code.match(/interface LoginForm \{([^}]*)\}/s);
    if (loginFormMatch) {
      const interfaceContent = loginFormMatch[1];
      const fieldMatches = interfaceContent.match(/(\w+)\??\s*:\s*string/g);
      
      if (fieldMatches) {
        for (const fieldMatch of fieldMatches) {
          const fieldName = fieldMatch.match(/(\w+)/)?.[1];
          const isOptional = fieldMatch.includes('?');
          
          if (fieldName) {
            const fieldType = this.detectFieldType(code, fieldName);
            analysis.fields.push({
              name: fieldName,
              type: fieldType,
              required: !isOptional
            });
          }
        }
      }
    }
    
    // Extract validation functions
    const validationMatches = code.match(/function validate\w+\([^)]*\):\s*boolean\s*\{[^}]*\}/g);
    if (validationMatches) {
      for (const funcMatch of validationMatches) {
        const funcName = funcMatch.match(/function (validate\w+)/)?.[1];
        if (funcName) {
          analysis.validationFunctions.push({
            name: funcName,
            code: funcMatch
          });
        }
      }
    }
    
    // Check for authenticateUser function
    analysis.hasAuthenticateUser = code.includes('function authenticateUser');
    
    return analysis;
  }
  
  /**
   * Detect field type from HTML form or field name
   */
  private detectFieldType(code: string, fieldName: string): string {
    // Look for input type in HTML
    const inputRegex = new RegExp(`<input[^>]*id="${fieldName}"[^>]*type="([^"]*)"`, 'i');
    const inputMatch = code.match(inputRegex);
    
    if (inputMatch) {
      return inputMatch[1];
    }
    
    // Fallback to field name analysis
    const typeMap: { [key: string]: string } = {
      'email': 'email',
      'password': 'password',
      'phone': 'tel',
      'telephone': 'tel',
      'age': 'number',
      'number': 'number',
      'date': 'date',
      'url': 'url',
      'website': 'url'
    };
    
    return typeMap[fieldName.toLowerCase()] || 'text';
  }
  
  /**
   * Generate comprehensive test file
   */
  private generateTestFile(analysis: CodeAnalysis): string {
    const timestamp = new Date().toISOString();
    
    let testContent = `// Generated by Frontend Tests Agent üß™
// Created: ${timestamp}
// Agent: agent/frontend-tests.ts
// Tests based on actual frontend.ts structure

import { describe, it, expect } from "vitest";

// Extracted validation functions from frontend.ts
`;

    // Include all validation functions found in the code
    for (const func of analysis.validationFunctions) {
      testContent += func.code + '\n\n';
    }

    // If no validation functions found, create basic ones
    if (analysis.validationFunctions.length === 0) {
      for (const field of analysis.fields) {
        if (field.name !== 'username' && field.name !== 'password') {
          testContent += this.generateValidationFunction(field.name, field.type) + '\n\n';
        }
      }
      
      // Add basic username/password validation if not found
      if (!analysis.validationFunctions.some(f => f.name === 'validateUsername')) {
        testContent += `function validateUsername(username: string): boolean {
  return username.length >= 3 && username.length <= 20;
}

`;
      }
      
      if (!analysis.validationFunctions.some(f => f.name === 'validatePassword')) {
        testContent += `function validatePassword(password: string): boolean {
  return password.length >= 6;
}

`;
      }
    }

    testContent += `describe("Frontend Validation Tests", () => {
`;

    // Generate tests for each field
    for (const field of analysis.fields) {
      testContent += this.generateFieldTests(field);
    }

    // Generate integration test
    testContent += this.generateIntegrationTest(analysis);

    testContent += `});

describe("Form Structure Tests", () => {
  it("should have correct field structure", () => {
    const expectedFields = ${JSON.stringify(analysis.fields.map(f => f.name))};
    expect(expectedFields.length).toBe(${analysis.fields.length});
    
    // Verify required fields
    const requiredFields = ${JSON.stringify(analysis.fields.filter(f => f.required).map(f => f.name))};
    expect(requiredFields).toContain('username');
    expect(requiredFields).toContain('password');
  });
  
  it("should have validation functions for all fields", () => {
    ${analysis.fields.map(field => 
      `expect(typeof validate${this.capitalize(field.name)}).toBe('function');`
    ).join('\n    ')}
  });
});`;

    return testContent;
  }
  
  /**
   * Generate validation function if not found in code
   */
  private generateValidationFunction(fieldName: string, fieldType: string): string {
    switch (fieldType) {
      case 'email':
        return `function validate${this.capitalize(fieldName)}(${fieldName}: string): boolean {
  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;
  return emailRegex.test(${fieldName});
}`;
      
      case 'tel':
        return `function validate${this.capitalize(fieldName)}(${fieldName}: string): boolean {
  const phoneRegex = /^[\\+]?[1-9][\\d]{0,15}$/;
  return phoneRegex.test(${fieldName}.replace(/[\\s\\-\\(\\)]/g, ''));
}`;
      
      case 'number':
        return `function validate${this.capitalize(fieldName)}(${fieldName}: string): boolean {
  const num = parseInt(${fieldName});
  return !isNaN(num) && num > 0;
}`;
      
      case 'url':
        return `function validate${this.capitalize(fieldName)}(${fieldName}: string): boolean {
  try {
    new URL(${fieldName});
    return true;
  } catch {
    return false;
  }
}`;
      
      default:
        return `function validate${this.capitalize(fieldName)}(${fieldName}: string): boolean {
  return ${fieldName}.length >= 2 && ${fieldName}.length <= 50;
}`;
    }
  }
  
  /**
   * Generate tests for a specific field
   */
  private generateFieldTests(field: FormField): string {
    const capitalizedName = this.capitalize(field.name);
    
    let tests = `
  describe("validate${capitalizedName}", () => {
    it("should accept valid ${field.name}", () => {`;

    // Generate valid test cases based on field type
    const validValues = this.getValidTestValues(field.name, field.type);
    for (const value of validValues) {
      tests += `
      expect(validate${capitalizedName}("${value}")).toBe(true);`;
    }

    tests += `
    });

    it("should reject invalid ${field.name}", () => {`;

    // Generate invalid test cases
    const invalidValues = this.getInvalidTestValues(field.name, field.type);
    for (const value of invalidValues) {
      tests += `
      expect(validate${capitalizedName}("${value}")).toBe(false);`;
    }

    tests += `
    });
  });
`;

    return tests;
  }
  
  /**
   * Generate integration test based on actual fields
   */
  private generateIntegrationTest(analysis: CodeAnalysis): string {
    const testData: { [key: string]: string } = {};
    
    for (const field of analysis.fields) {
      testData[field.name] = this.getTestValue(field.name, field.type);
    }
    
    let integrationTest = `
  describe("Integration Tests", () => {
    it("should validate complete form with all current fields", () => {
      const validForm = ${JSON.stringify(testData, null, 8)};
      
      // Test all validation functions for current fields`;

    for (const field of analysis.fields) {
      integrationTest += `
      expect(validate${this.capitalize(field.name)}(validForm.${field.name})).toBe(true);`;
    }

    integrationTest += `
    });
    
    it("should handle form with missing optional fields", () => {
      const minimalForm = {`;

    // Add only required fields
    const requiredFields = analysis.fields.filter(f => f.required);
    for (let i = 0; i < requiredFields.length; i++) {
      const field = requiredFields[i];
      integrationTest += `
        ${field.name}: "${this.getTestValue(field.name, field.type)}"${i < requiredFields.length - 1 ? ',' : ''}`;
    }

    integrationTest += `
      };
      
      // Test required field validations`;

    for (const field of requiredFields) {
      integrationTest += `
      expect(validate${this.capitalize(field.name)}(minimalForm.${field.name})).toBe(true);`;
    }

    integrationTest += `
    });
  });
`;

    return integrationTest;
  }
  
  /**
   * Generate HTML test report
   */
  private generateHtmlReport(analysis: CodeAnalysis): string {
    const timestamp = new Date().toISOString();
    
    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frontend Tests Report</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            text-align: center;
        }
        .header h1 {
            margin: 0;
            font-size: 2.5em;
        }
        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
        }
        .section {
            background: white;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .section h2 {
            color: #333;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
            margin-top: 0;
        }
        .field-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .field-card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            background: #f9f9f9;
        }
        .field-name {
            font-weight: bold;
            color: #667eea;
            font-size: 1.1em;
        }
        .field-details {
            margin-top: 10px;
            font-size: 0.9em;
            color: #666;
        }
        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: bold;
            margin: 2px;
        }
        .badge.required {
            background-color: #ff6b6b;
            color: white;
        }
        .badge.optional {
            background-color: #4ecdc4;
            color: white;
        }
        .badge.type {
            background-color: #45b7d1;
            color: white;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .stat-card {
            text-align: center;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 10px;
        }
        .stat-number {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
        }
        .validation-list {
            list-style: none;
            padding: 0;
        }
        .validation-list li {
            padding: 10px;
            margin: 5px 0;
            background: #f0f8ff;
            border-left: 4px solid #667eea;
            border-radius: 4px;
        }
        .code-block {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            overflow-x: auto;
            margin-top: 10px;
        }
        .timestamp {
            text-align: center;
            color: #666;
            font-size: 0.9em;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üß™ Frontend Tests Report</h1>
        <p>Comprehensive analysis of frontend.ts structure and test coverage</p>
    </div>

    <div class="section">
        <h2>üìä Test Coverage Summary</h2>
        <div class="stats">
            <div class="stat-card">
                <div class="stat-number">${analysis.fields.length}</div>
                <div class="stat-label">Form Fields</div>
            </div>
            <div class="stat-card">
                <div class="stat-number">${analysis.validationFunctions.length}</div>
                <div class="stat-label">Validation Functions</div>
            </div>
            <div class="stat-card">
                <div class="stat-number">${analysis.fields.filter(f => f.required).length}</div>
                <div class="stat-label">Required Fields</div>
            </div>
            <div class="stat-card">
                <div class="stat-number">${analysis.fields.filter(f => !f.required).length}</div>
                <div class="stat-label">Optional Fields</div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>üìù Form Fields Analysis</h2>
        <div class="field-grid">
            ${analysis.fields.map(field => `
            <div class="field-card">
                <div class="field-name">${field.name}</div>
                <div class="field-details">
                    <span class="badge type">${field.type}</span>
                    <span class="badge ${field.required ? 'required' : 'optional'}">
                        ${field.required ? 'Required' : 'Optional'}
                    </span>
                </div>
                <div class="field-details">
                    Validation: validate${this.capitalize(field.name)}()
                </div>
            </div>
            `).join('')}
        </div>
    </div>

    <div class="section">
        <h2>üîß Validation Functions</h2>
        <ul class="validation-list">
            ${analysis.validationFunctions.map(func => `
            <li>
                <strong>${func.name}()</strong>
                <div class="code-block">${func.code.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</div>
            </li>
            `).join('')}
        </ul>
        
        ${analysis.validationFunctions.length === 0 ? `
        <p><em>No validation functions found in source code. Tests will include generated validation functions.</em></p>
        ` : ''}
    </div>

    <div class="section">
        <h2>üéØ Test Strategy</h2>
        <ul>
            <li><strong>Field Validation Tests:</strong> Each field gets comprehensive validation testing with valid and invalid inputs</li>
            <li><strong>Integration Tests:</strong> Complete form validation with all current fields</li>
            <li><strong>Structure Tests:</strong> Verify form structure matches expected field configuration</li>
            <li><strong>Edge Cases:</strong> Test with missing optional fields and boundary conditions</li>
        </ul>
        
        <h3>Generated Test Cases:</h3>
        <ul>
            ${analysis.fields.map(field => `
            <li><strong>${field.name}:</strong> ${this.getValidTestValues(field.name, field.type).length} valid cases, ${this.getInvalidTestValues(field.name, field.type).length} invalid cases</li>
            `).join('')}
        </ul>
    </div>

    <div class="section">
        <h2>üöÄ Running Tests</h2>
        <div class="code-block">
# Run the generated tests
npm test

# Run tests with coverage
npm run test:coverage

# Run tests in watch mode
npm run test:watch
        </div>
    </div>

    <div class="timestamp">
        Generated by Frontend Tests Agent üß™<br>
        ${timestamp}
    </div>
</body>
</html>`;
  }
  
  /**
   * Get valid test values for field type
   */
  private getValidTestValues(fieldName: string, fieldType: string): string[] {
    switch (fieldType) {
      case 'email':
        return ['user@example.com', 'test.email@domain.org', 'admin@company.co.uk'];
      case 'tel':
        return ['+1234567890', '1234567890', '+44123456789'];
      case 'number':
        return ['25', '100', '1'];
      case 'url':
        return ['https://example.com', 'http://test.org', 'https://www.google.com'];
      case 'password':
        return ['password123', 'securePass456', 'myPassword789'];
      case 'text':
      default:
        if (fieldName === 'username') {
          return ['admin', 'user123', 'testuser'];
        }
        return ['validtext', 'test123', 'sample'];
    }
  }
  
  /**
   * Get invalid test values for field type
   */
  private getInvalidTestValues(fieldName: string, fieldType: string): string[] {
    switch (fieldType) {
      case 'email':
        return ['invalid-email', 'user@', '@domain.com', 'user.domain.com', ''];
      case 'tel':
        return ['abc123', '123', '+', 'phone'];
      case 'number':
        return ['abc', '-5', '0', 'text'];
      case 'url':
        return ['not-a-url', 'http://', 'invalid.url', 'text'];
      case 'password':
        return ['123', 'short', '', 'ab'];
      case 'text':
      default:
        if (fieldName === 'username') {
          return ['ab', '', 'x'.repeat(25)];
        }
        return ['a', '', 'x'.repeat(100)];
    }
  }
  
  /**
   * Get test value for field type
   */
  private getTestValue(fieldName: string, fieldType: string): string {
    switch (fieldType) {
      case 'email':
        return 'test@example.com';
      case 'tel':
        return '+1234567890';
      case 'number':
        return '25';
      case 'url':
        return 'https://example.com';
      case 'password':
        return 'password123';
      case 'text':
      default:
        if (fieldName === 'username') {
          return 'testuser';
        }
        return 'testvalue';
    }
  }
  
  /**
   * Check if backend changes are needed based on frontend analysis
   */
  private async checkForBackendRequests(analysis: CodeAnalysis): Promise<void> {
    // Check if instructions mention email but frontend doesn't have it
    const instructions = this.readInstructions();
    const hasEmailInInstructions = /email/i.test(instructions);
    const hasEmailInFrontend = analysis.fields.some(f => f.name === 'email');
    
    if (hasEmailInInstructions && !hasEmailInFrontend) {
      console.log('  üîç Instructions mention email but frontend lacks email field');
      console.log('  üì¨ Requesting backend to add email support...');
      await this.requestBackendApiChange({
        name: "email",
        type: "string", 
        required: true,
        format: "email"
      });
    }
  }
  
  /**
   * Read instructions from instructions.md
   */
  private readInstructions(): string {
    try {
      return readFileSync('instructions.md', 'utf8');
    } catch (error) {
      return '';
    }
  }

  /**
   * Request backend API change via mailbox system
   */
  async requestBackendApiChange(field = { name: "email", type: "string", required: true, format: "email" }): Promise<void> {
    console.log('  üì¨ Frontend Tests Agent: Requesting backend API change...');
    
    try {
      const id = `REQ-${new Date().toISOString().slice(0, 10)}-${randomUUID().slice(0, 6)}`;
      const request = {
        id,
        from: "frontend-tests-agent",
        to: "backend-agent",
        intent: "API_CHANGE",
        scope: "backend-users",
        payload: {
          resource: "/auth/login",
          change: "ADD_FIELD",
          field
        },
        links: { spec: "contracts/auth/openapi.yaml" },
        policySnapshot: {
          writePaths: ["outputs/backend/**"],
          denyPaths: ["src/**", "apps/**"]
        },
        createdAt: new Date().toISOString()
      };
      
      const dir = "comms/requests/to-backend";
      await fs.mkdir(dir, { recursive: true });
      await fs.writeFile(join(dir, `${id}.json`), JSON.stringify(request, null, 2));
      
      console.log(`  üì® Frontend ‚Üí Backend request: ${id}`);
      console.log(`  üîß Requesting: ${request.payload.change} ${field.name} to ${request.payload.resource}`);
      
    } catch (error: any) {
      console.error('  ‚ùå Frontend mailbox request error:', error.message);
    }
  }

  /**
   * Capitalize first letter of string
   */
  private capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
}

/**
 * Interfaces for code analysis
 */
interface CodeAnalysis {
  fields: FormField[];
  validationFunctions: ValidationFunction[];
  interfaces: string[];
  hasAuthenticateUser: boolean;
}

interface FormField {
  name: string;
  type: string;
  required: boolean;
}

interface ValidationFunction {
  name: string;
  code: string;
}