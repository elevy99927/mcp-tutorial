import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';

/**
 * Backend Tests Agent
 * Reads backend.ts and creates comprehensive tests based on actual API structure
 */
export class BackendTestsAgent {
  
  async generateBackendTests(): Promise<void> {
    console.log('  🧪 Backend Tests Agent: Analyzing backend code...');
    
    try {
      // Ensure outputs/tests directory exists
      this.ensureTestDirectory();
      
      // Read and analyze backend.ts
      const backendCode = this.readBackendCode();
      const codeAnalysis = this.analyzeBackendCode(backendCode);
      
      console.log(`  🔍 Found ${codeAnalysis.endpoints.length} API endpoints`);
      console.log(`  🔍 Found ${codeAnalysis.models.length} data models`);
      
      // Generate test file
      const testContent = this.generateTestFile(codeAnalysis);
      const testFile = 'outputs/tests/backend.test.ts';
      writeFileSync(testFile, testContent);
      console.log(`  ✅ Generated ${testFile}`);
      
    } catch (error: any) {
      console.error('  ❌ Backend Tests Agent error:', error.message);
    }
  }
  
  /**
   * Ensure test directory exists
   */
  private ensureTestDirectory(): void {
    if (!existsSync('outputs')) {
      mkdirSync('outputs');
    }
    if (!existsSync('outputs/tests')) {
      mkdirSync('outputs/tests');
      console.log('  📁 Created outputs/tests/ directory');
    }
  }
  
  /**
   * Read backend.ts code
   */
  private readBackendCode(): string {
    try {
      return readFileSync('src/backend.ts', 'utf8');
    } catch (error) {
      throw new Error('Could not read src/backend.ts');
    }
  }
  
  /**
   * Analyze backend code to extract API structure
   */
  private analyzeBackendCode(code: string): BackendAnalysis {
    const analysis: BackendAnalysis = {
      endpoints: [],
      models: [],
      validationFunctions: [],
      hasAuthentication: false
    };
    
    // Extract API endpoints
    const endpointMatches = code.match(/app\.(get|post|put|delete)\(['"`]([^'"`]+)['"`]/g);
    if (endpointMatches) {
      for (const match of endpointMatches) {
        const methodMatch = match.match(/app\.(\w+)/);
        const pathMatch = match.match(/['"`]([^'"`]+)['"`]/);
        
        if (methodMatch && pathMatch) {
          analysis.endpoints.push({
            method: methodMatch[1].toUpperCase(),
            path: pathMatch[1],
            protected: match.includes('authenticateToken')
          });
        }
      }
    }
    
    // Extract data models (interfaces)
    const interfaceMatches = code.match(/interface\s+(\w+)\s*\{[^}]*\}/g);
    if (interfaceMatches) {
      for (const interfaceMatch of interfaceMatches) {
        const nameMatch = interfaceMatch.match(/interface\s+(\w+)/);
        if (nameMatch) {
          analysis.models.push(nameMatch[1]);
        }
      }
    }
    
    // Extract validation functions
    const validationMatches = code.match(/function validate\w+\([^)]*\):\s*boolean/g);
    if (validationMatches) {
      for (const funcMatch of validationMatches) {
        const nameMatch = funcMatch.match(/function (validate\w+)/);
        if (nameMatch) {
          analysis.validationFunctions.push(nameMatch[1]);
        }
      }
    }
    
    // Check for authentication
    analysis.hasAuthentication = code.includes('authenticateToken') || code.includes('jwt');
    
    return analysis;
  }  

  /**
   * Generate comprehensive test file
   */
  private generateTestFile(analysis: BackendAnalysis): string {
    const timestamp = new Date().toISOString();
    
    let testContent = `// Generated by Backend Tests Agent 🧪
// Created: ${timestamp}
// Agent: agent/backend-tests.ts
// Tests based on actual backend.ts structure

import { describe, it, expect, beforeAll, afterAll } from "vitest";
import request from "supertest";

// Mock backend server for testing
const BASE_URL = 'http://localhost:3001';

describe("Backend API Tests", () => {
  let authToken: string;

  beforeAll(async () => {
    // Setup test authentication if needed
    ${analysis.hasAuthentication ? `
    const loginResponse = await request(BASE_URL)
      .post('/api/auth/login')
      .send({
        username: 'admin',
        password: 'password123'
      });
    
    if (loginResponse.body.token) {
      authToken = loginResponse.body.token;
    }` : '// No authentication setup needed'}
  });

`;

    // Generate endpoint tests
    for (const endpoint of analysis.endpoints) {
      testContent += this.generateEndpointTests(endpoint);
    }

    // Generate validation tests
    if (analysis.validationFunctions.length > 0) {
      testContent += `
  describe("Validation Functions", () => {
`;
      for (const func of analysis.validationFunctions) {
        testContent += this.generateValidationTests(func);
      }
      testContent += `  });
`;
    }

    // Generate model tests
    if (analysis.models.length > 0) {
      testContent += `
  describe("Data Models", () => {
    it("should have correct model interfaces", () => {
      // Test model structure
      const models = ${JSON.stringify(analysis.models)};
      expect(models.length).toBeGreaterThan(0);
    });
  });
`;
    }

    testContent += `});`;

    return testContent;
  }
  
  /**
   * Generate tests for specific endpoint
   */
  private generateEndpointTests(endpoint: ApiEndpoint): string {
    const testName = `${endpoint.method} ${endpoint.path}`;
    const pathSegments = endpoint.path.split('/').filter(Boolean);
    const resourceName = pathSegments[pathSegments.length - 1] || 'endpoint';
    
    let tests = `
  describe("${testName}", () => {`;

    if (endpoint.method === 'GET') {
      tests += `
    it("should return successful response", async () => {
      const response = await request(BASE_URL)
        .get('${endpoint.path}')${endpoint.protected ? `
        .set('Authorization', \`Bearer \${authToken}\`)` : ''};
      
      expect(response.status).toBeLessThan(500);
    });`;

      if (endpoint.protected) {
        tests += `
    
    it("should require authentication", async () => {
      const response = await request(BASE_URL)
        .get('${endpoint.path}');
      
      expect(response.status).toBe(401);
    });`;
      }
    }

    if (endpoint.method === 'POST') {
      tests += `
    it("should create ${resourceName} successfully", async () => {
      const testData = ${this.generateTestData(resourceName)};
      
      const response = await request(BASE_URL)
        .post('${endpoint.path}')${endpoint.protected ? `
        .set('Authorization', \`Bearer \${authToken}\`)` : ''}
        .send(testData);
      
      expect(response.status).toBeLessThan(500);
    });`;

      tests += `
    
    it("should validate input data", async () => {
      const invalidData = {};
      
      const response = await request(BASE_URL)
        .post('${endpoint.path}')${endpoint.protected ? `
        .set('Authorization', \`Bearer \${authToken}\`)` : ''}
        .send(invalidData);
      
      expect([400, 422]).toContain(response.status);
    });`;
    }

    tests += `
  });
`;

    return tests;
  }
  
  /**
   * Generate tests for validation functions
   */
  private generateValidationTests(functionName: string): string {
    const fieldName = functionName.replace('validate', '').toLowerCase();
    
    let tests = `
    describe("${functionName}", () => {
      it("should validate correct ${fieldName}", () => {
        // Add specific validation tests based on field type
        expect(typeof ${functionName}).toBe('function');
      });
      
      it("should reject invalid ${fieldName}", () => {
        // Add specific rejection tests
        expect(typeof ${functionName}).toBe('function');
      });
    });
`;

    return tests;
  }
  
  /**
   * Generate test data for endpoint
   */
  private generateTestData(resourceName: string): string {
    switch (resourceName.toLowerCase()) {
      case 'login':
        return JSON.stringify({
          username: 'testuser',
          password: 'testpass123'
        });
      case 'users':
        return JSON.stringify({
          username: 'newuser',
          email: 'test@example.com',
          password: 'password123'
        });
      default:
        return JSON.stringify({
          name: 'test',
          value: 'test-value'
        });
    }
  }
}

/**
 * Interfaces for backend analysis
 */
interface BackendAnalysis {
  endpoints: ApiEndpoint[];
  models: string[];
  validationFunctions: string[];
  hasAuthentication: boolean;
}

interface ApiEndpoint {
  method: string;
  path: string;
  protected: boolean;
}