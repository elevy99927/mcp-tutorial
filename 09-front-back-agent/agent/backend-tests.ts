import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';

/**
 * Backend Tests Agent
 * Reads backend.ts and creates comprehensive tests based on actual API structure
 */
export class BackendTestsAgent {
  
  async generateBackendTests(): Promise<void> {
    console.log('  🧪 Backend Tests Agent: Analyzing backend code...');
    
    try {
      // Ensure outputs/tests directory exists
      this.ensureTestDirectory();
      
      // Read and analyze backend.ts
      const backendCode = this.readBackendCode();
      const codeAnalysis = this.analyzeBackendCode(backendCode);
      
      console.log(`  🔍 Found ${codeAnalysis.endpoints.length} API endpoints`);
      console.log(`  🔍 Found ${codeAnalysis.models.length} data models`);
      
      // Generate test file
      const testContent = this.generateTestFile(codeAnalysis);
      const testFile = 'outputs/tests/backend.test.ts';
      writeFileSync(testFile, testContent);
      console.log(`  ✅ Generated ${testFile}`);
      
    } catch (error: any) {
      console.error('  ❌ Backend Tests Agent error:', error.message);
    }
  }
  
  /**
   * Ensure test directory exists
   */
  private ensureTestDirectory(): void {
    if (!existsSync('outputs')) {
      mkdirSync('outputs');
    }
    if (!existsSync('outputs/tests')) {
      mkdirSync('outputs/tests');
      console.log('  📁 Created outputs/tests/ directory');
    }
  }
  
  /**
   * Read backend.ts code
   */
  private readBackendCode(): string {
    try {
      return readFileSync('src/backend.ts', 'utf8');
    } catch (error) {
      throw new Error('Could not read src/backend.ts');
    }
  }
  
  /**
   * Analyze backend code to extract API structure
   */
  private analyzeBackendCode(code: string): BackendAnalysis {
    const analysis: BackendAnalysis = {
      endpoints: [],
      models: [],
      validationFunctions: [],
      hasAuthentication: false
    };
    
    // Extract API endpoints
    const endpointMatches = code.match(/app\.(get|post|put|delete)\(['"`]([^'"`]+)['"`]/g);
    if (endpointMatches) {
      for (const match of endpointMatches) {
        const methodMatch = match.match(/app\.(\w+)/);
        const pathMatch = match.match(/['"`]([^'"`]+)['"`]/);
        
        if (methodMatch && pathMatch) {
          analysis.endpoints.push({
            method: methodMatch[1].toUpperCase(),
            path: pathMatch[1],
            protected: match.includes('authenticateToken')
          });
        }
      }
    }
    
    // Extract data models (interfaces)
    const interfaceMatches = code.match(/interface\s+(\w+)\s*\{[^}]*\}/g);
    if (interfaceMatches) {
      for (const interfaceMatch of interfaceMatches) {
        const nameMatch = interfaceMatch.match(/interface\s+(\w+)/);
        if (nameMatch) {
          analysis.models.push(nameMatch[1]);
        }
      }
    }
    
    // Extract validation functions (but don't try to import them)
    const validationMatches = code.match(/function validate\w+\([^)]*\):\s*boolean/g);
    if (validationMatches) {
      for (const funcMatch of validationMatches) {
        const nameMatch = funcMatch.match(/function (validate\w+)/);
        if (nameMatch) {
          analysis.validationFunctions.push(nameMatch[1]);
        }
      }
    }
    
    // Check for authentication
    analysis.hasAuthentication = code.includes('authenticateToken') || code.includes('jwt');
    
    return analysis;
  }  

  /**
   * Generate comprehensive test file
   */
  private generateTestFile(analysis: BackendAnalysis): string {
    const timestamp = new Date().toISOString();
    
    let testContent = `// Generated by Backend Tests Agent 🧪
// Created: ${timestamp}
// Agent: agent/backend-tests.ts
// Tests based on actual backend.ts structure

import { describe, it, expect, beforeAll, afterAll } from "vitest";
import request from "supertest";

// Backend server URL for testing
const BASE_URL = 'http://localhost:3001';

describe("Backend API Tests", () => {
  let authToken: string;

  beforeAll(async () => {
    // Setup test authentication if needed
    ${analysis.hasAuthentication ? `
    const loginResponse = await request(BASE_URL)
      .post('/api/auth/login')
      .send({
        username: 'admin',
        password: '123456'
      });
    
    if (loginResponse.body.token) {
      authToken = loginResponse.body.token;
    }` : '// No authentication setup needed'}
  });

`;

    // Generate endpoint tests
    for (const endpoint of analysis.endpoints) {
      testContent += this.generateEndpointTests(endpoint);
    }

    // Generate validation tests through API endpoints (not direct function calls)
    if (analysis.validationFunctions.length > 0) {
      testContent += `
  describe("Validation Testing", () => {
    it("should validate input through API endpoints", () => {
      // Validation functions are tested through the API endpoints above
      // This ensures validation works in the actual request/response cycle
      expect(true).toBe(true);
    });
  });
`;
    }

    // Generate model tests
    if (analysis.models.length > 0) {
      testContent += `
  describe("Data Models", () => {
    it("should have consistent response structure", async () => {
      // Test that API responses follow expected patterns
      const healthResponse = await request(BASE_URL).get('/api/health');
      
      if (healthResponse.status === 200) {
        expect(healthResponse.body).toHaveProperty('status');
        expect(healthResponse.body).toHaveProperty('timestamp');
        expect(healthResponse.body).toHaveProperty('service');
      }
    });
  });
`;
    }

    testContent += `});`;

    return testContent;
  }
  
  /**
   * Generate tests for specific endpoint
   */
  private generateEndpointTests(endpoint: ApiEndpoint): string {
    const testName = `${endpoint.method} ${endpoint.path}`;
    const pathSegments = endpoint.path.split('/').filter(Boolean);
    const resourceName = pathSegments[pathSegments.length - 1] || 'endpoint';
    
    let tests = `
  describe("${testName}", () => {`;

    if (endpoint.method === 'GET') {
      tests += `
    it("should return successful response", async () => {
      const response = await request(BASE_URL)
        .get('${endpoint.path}')${endpoint.protected ? `
        .set('Authorization', \`Bearer \${authToken}\`)` : ''};
      
      expect(response.status).toBeLessThan(500);
      ${this.generateResponseValidation(endpoint.path)}
    });`;

      if (endpoint.protected) {
        tests += `
    
    it("should require authentication", async () => {
      const response = await request(BASE_URL)
        .get('${endpoint.path}');
      
      expect(response.status).toBe(401);
    });`;
      }
    }

    if (endpoint.method === 'POST') {
      tests += `
    it("should handle valid ${resourceName} data", async () => {
      const testData = ${this.generateTestData(resourceName)};
      
      const response = await request(BASE_URL)
        .post('${endpoint.path}')${endpoint.protected ? `
        .set('Authorization', \`Bearer \${authToken}\`)` : ''}
        .send(testData);
      
      expect(response.status).toBeLessThan(500);
      ${this.generateResponseValidation(endpoint.path, 'success')}
    });`;

      tests += `
    
    it("should validate input data", async () => {
      const invalidData = {};
      
      const response = await request(BASE_URL)
        .post('${endpoint.path}')${endpoint.protected ? `
        .set('Authorization', \`Bearer \${authToken}\`)` : ''}
        .send(invalidData);
      
      expect([400, 422]).toContain(response.status);
      if (response.body) {
        expect(response.body).toHaveProperty('success');
        expect(response.body.success).toBe(false);
      }
    });`;

      // Add specific validation tests for known endpoints
      if (resourceName === 'users') {
        tests += `
    
    it("should validate username requirements", async () => {
      const invalidUser = {
        username: 'ab', // too short
        password: 'validpassword123'
      };
      
      const response = await request(BASE_URL)
        .post('${endpoint.path}')
        .send(invalidUser);
      
      expect(response.status).toBe(400);
      expect(response.body.success).toBe(false);
    });

    it("should validate password requirements", async () => {
      const invalidUser = {
        username: 'validuser',
        password: '123' // too short
      };
      
      const response = await request(BASE_URL)
        .post('${endpoint.path}')
        .send(invalidUser);
      
      expect(response.status).toBe(400);
      expect(response.body.success).toBe(false);
    });`;
      }

      if (resourceName === 'login') {
        tests += `
    
    it("should reject invalid credentials", async () => {
      const invalidCredentials = {
        username: 'wronguser',
        password: 'wrongpass'
      };
      
      const response = await request(BASE_URL)
        .post('${endpoint.path}')
        .send(invalidCredentials);
      
      expect(response.status).toBe(400);
      expect(response.body.success).toBe(false);
    });`;
      }
    }

    tests += `
  });
`;

    return tests;
  }
  
  /**
   * Generate response validation based on endpoint
   */
  private generateResponseValidation(path: string, expectSuccess?: string): string {
    if (path === '/api/health') {
      return `if (response.status === 200) {
        expect(response.body).toHaveProperty('status');
        expect(response.body.status).toBe('healthy');
      }`;
    }
    
    if (path === '/') {
      return `if (response.status === 200) {
        expect(response.body).toHaveProperty('service');
        expect(response.body).toHaveProperty('endpoints');
      }`;
    }
    
    if (path === '/api/users' && !expectSuccess) {
      return `if (response.status === 200) {
        expect(response.body).toHaveProperty('users');
        expect(response.body).toHaveProperty('total');
        expect(Array.isArray(response.body.users)).toBe(true);
      }`;
    }
    
    if (expectSuccess) {
      return `if (response.status < 400) {
        expect(response.body).toHaveProperty('success');
      }`;
    }
    
    return '';
  }
  
  /**
   * Generate test data for endpoint
   */
  private generateTestData(resourceName: string): string {
    switch (resourceName.toLowerCase()) {
      case 'login':
        return JSON.stringify({
          username: 'admin',
          password: '123456'
        });
      case 'users':
        return JSON.stringify({
          username: 'testuser123',
          password: 'password123'
        });
      default:
        return JSON.stringify({
          name: 'test',
          value: 'test-value'
        });
    }
  }
}

/**
 * Interfaces for backend analysis
 */
interface BackendAnalysis {
  endpoints: ApiEndpoint[];
  models: string[];
  validationFunctions: string[];
  hasAuthentication: boolean;
}

interface ApiEndpoint {
  method: string;
  path: string;
  protected: boolean;
}